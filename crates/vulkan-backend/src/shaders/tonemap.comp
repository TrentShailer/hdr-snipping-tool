#version 450

// Get f16 capabilities
#if defined(GL_AMD_gpu_shader_half_float)
	#extension GL_AMD_gpu_shader_half_float : require
#elif defined(GL_NV_gpu_shader5)
	#extension GL_NV_gpu_shader5 : require
#else
	#error No extension available for FP16.
#endif

const uint WORKGROUP_SIZE = 32;

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;


layout(set = 0, binding = 0) buffer InputLayout
{
    float16_t input_buffer[];
};

layout(set = 0, binding = 1) buffer OutputLayout
{
    uint output_buffer[];
};

layout(set = 1, binding = 0) uniform Config
{
	uint input_length;
	uint input_width;
	uint input_height;
	float16_t alpha;
	float16_t gamma;
	float16_t maximum;
	// float16_t padding;
};

// float16_t tonemap(float16_t value) {
// 	float16_t ratio = value/maximum;
// 	return alpha * (-exp(-gamma * ratio) * (1.0hf - ratio) + 1.0hf);
// }

float16_t tonemap(float16_t value) {
	float16_t ratio = value/maximum;
	return clamp(alpha * pow(ratio, gamma), 0.0hf, 1.0hf);
}

void main() {
	uint pixel_x = gl_WorkGroupID.x * WORKGROUP_SIZE + gl_LocalInvocationID.x;
	uint pixel_y = gl_WorkGroupID.y * WORKGROUP_SIZE + gl_LocalInvocationID.y;

	if (pixel_x > input_width) {
		return;
	}
	if (pixel_y > input_height) {
		return;
	}

	uint pixel_index_1d = (pixel_y * input_width + pixel_x) * 4;

	float16_t r_in = input_buffer[pixel_index_1d];
	float16_t g_in = input_buffer[pixel_index_1d + 1];
	float16_t b_in = input_buffer[pixel_index_1d + 2];
	float16_t a_in = input_buffer[pixel_index_1d + 3];



	uint r_out = uint(tonemap(r_in)	* 255.0hf);
	uint g_out = uint(tonemap(g_in)	* 255.0hf);
	uint b_out = uint(tonemap(b_in)	* 255.0hf);
	uint a_out = uint(a_in 			* 255.0hf);

	uint out_color = a_out << 24 | b_out << 16 | g_out << 8 | r_out;

	output_buffer[pixel_y * input_width + pixel_x] = out_color;
}

