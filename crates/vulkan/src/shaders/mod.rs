#![doc = "Generated by rspirv-bindgen v0.2.0"]
#![allow(unused)]
pub mod maximum_reduction {
    use ash_helper::VK_GLOBAL_ALLOCATOR;

    pub mod compute_main {
        pub const ENTRY_POINT: &core::ffi::CStr = c"main";
        pub const STAGE: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::COMPUTE;
        pub const DISPATCH_SIZE: [u32; 3] = [64u32, 4u32, 1u32];
    }
    pub unsafe fn set_layouts(
        device: &ash::Device,
        flags: ash::vk::DescriptorSetLayoutCreateFlags,
    ) -> Result<Vec<ash::vk::DescriptorSetLayout>, ash::vk::Result> {
        let set_0 = {
            let bindings = [
                ash::vk::DescriptorSetLayoutBinding::default()
                    .binding(0u32)
                    .descriptor_type(ash::vk::DescriptorType::STORAGE_IMAGE)
                    .descriptor_count(1)
                    .stage_flags(ash::vk::ShaderStageFlags::COMPUTE),
                ash::vk::DescriptorSetLayoutBinding::default()
                    .binding(1u32)
                    .descriptor_type(ash::vk::DescriptorType::STORAGE_BUFFER)
                    .descriptor_count(1)
                    .stage_flags(ash::vk::ShaderStageFlags::COMPUTE),
            ];
            let layout_info = ash::vk::DescriptorSetLayoutCreateInfo::default()
                .bindings(&bindings)
                .flags(flags);
            match unsafe {
                device.create_descriptor_set_layout(&layout_info, VK_GLOBAL_ALLOCATOR.as_deref())
            } {
                Ok(set) => set,
                Err(error) => {
                    return Err(error);
                }
            }
        };
        Ok(vec![set_0])
    }
    pub const BYTES: &[u8] = {
        #[repr(C, align(4))]
        struct Aligned<T: ?Sized>(T);
        const ALIGNED_DATA: &Aligned<[u8]> = &Aligned(*include_bytes!("spv/maximum_reduction.spv"));
        &ALIGNED_DATA.0
    };
}
pub mod render_capture {
    use ash_helper::VK_GLOBAL_ALLOCATOR;

    pub mod vertex_main {
        pub const ENTRY_POINT: &core::ffi::CStr = c"vertexMain";
        pub const STAGE: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::VERTEX;
        #[repr(C)]
        #[derive(Clone, Copy, Debug, Default, bytemuck :: Zeroable, bytemuck :: Pod)]
        pub struct Vertex {
            pub position: [f32; 2usize],
            pub uv: [f32; 2usize],
        }
        pub fn vertex_binding_descriptions() -> [ash::vk::VertexInputBindingDescription; 1usize] {
            [ash::vk::VertexInputBindingDescription::default()
                .binding(0u32)
                .stride(16u32)
                .input_rate(ash::vk::VertexInputRate::VERTEX)]
        }
        pub fn vertex_attribute_descriptions() -> [ash::vk::VertexInputAttributeDescription; 2usize]
        {
            [
                ash::vk::VertexInputAttributeDescription::default()
                    .location(0u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32G32_SFLOAT)
                    .offset(0u32),
                ash::vk::VertexInputAttributeDescription::default()
                    .location(1u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32G32_SFLOAT)
                    .offset(8u32),
            ]
        }
        pub fn vertex_binding_descriptions_2_ext<'a>()
        -> [ash::vk::VertexInputBindingDescription2EXT<'a>; 1usize] {
            [ash::vk::VertexInputBindingDescription2EXT::default()
                .binding(0u32)
                .stride(16u32)
                .input_rate(ash::vk::VertexInputRate::VERTEX)
                .divisor(1)]
        }
        pub fn vertex_attribute_descriptions_2_ext<'a>()
        -> [ash::vk::VertexInputAttributeDescription2EXT<'a>; 2usize] {
            [
                ash::vk::VertexInputAttributeDescription2EXT::default()
                    .location(0u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32G32_SFLOAT)
                    .offset(0u32),
                ash::vk::VertexInputAttributeDescription2EXT::default()
                    .location(1u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32G32_SFLOAT)
                    .offset(8u32),
            ]
        }
    }
    pub mod fragment_main {
        pub const ENTRY_POINT: &core::ffi::CStr = c"fragmentMain";
        pub const STAGE: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::FRAGMENT;
    }
    #[repr(C)]
    #[derive(Clone, Copy, Debug, Default, bytemuck :: Zeroable, bytemuck :: Pod)]
    pub struct PushConstants {
        pub whitepoint: f32,
        pub max_brightness: f32,
        pub present_srgb: u32,
    }
    impl PushConstants {
        pub const STAGES: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::FRAGMENT;
        pub fn push_constant_range() -> ash::vk::PushConstantRange {
            ash::vk::PushConstantRange::default()
                .offset(0)
                .size(12u32)
                .stage_flags(ash::vk::ShaderStageFlags::FRAGMENT)
        }
    }
    pub unsafe fn set_layouts(
        device: &ash::Device,
        flags: ash::vk::DescriptorSetLayoutCreateFlags,
    ) -> Result<Vec<ash::vk::DescriptorSetLayout>, ash::vk::Result> {
        let set_0 = {
            let bindings = [ash::vk::DescriptorSetLayoutBinding::default()
                .binding(0u32)
                .descriptor_type(ash::vk::DescriptorType::COMBINED_IMAGE_SAMPLER)
                .descriptor_count(1)
                .stage_flags(ash::vk::ShaderStageFlags::FRAGMENT)];
            let layout_info = ash::vk::DescriptorSetLayoutCreateInfo::default()
                .bindings(&bindings)
                .flags(flags);
            match unsafe {
                device.create_descriptor_set_layout(&layout_info, VK_GLOBAL_ALLOCATOR.as_deref())
            } {
                Ok(set) => set,
                Err(error) => {
                    return Err(error);
                }
            }
        };
        Ok(vec![set_0])
    }
    pub const BYTES: &[u8] = {
        #[repr(C, align(4))]
        struct Aligned<T: ?Sized>(T);
        const ALIGNED_DATA: &Aligned<[u8]> = &Aligned(*include_bytes!("spv/render_capture.spv"));
        &ALIGNED_DATA.0
    };
}
pub mod render_line {
    pub mod vertex_main {
        pub const ENTRY_POINT: &core::ffi::CStr = c"vertexMain";
        pub const STAGE: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::VERTEX;
        #[repr(C)]
        #[derive(Clone, Copy, Debug, Default, bytemuck :: Zeroable, bytemuck :: Pod)]
        pub struct Vertex {
            pub index: u32,
        }
        pub fn vertex_binding_descriptions() -> [ash::vk::VertexInputBindingDescription; 1usize] {
            [ash::vk::VertexInputBindingDescription::default()
                .binding(0u32)
                .stride(4u32)
                .input_rate(ash::vk::VertexInputRate::VERTEX)]
        }
        pub fn vertex_attribute_descriptions() -> [ash::vk::VertexInputAttributeDescription; 1usize]
        {
            [ash::vk::VertexInputAttributeDescription::default()
                .location(0u32)
                .binding(0u32)
                .format(ash::vk::Format::R32_UINT)
                .offset(0u32)]
        }
        pub fn vertex_binding_descriptions_2_ext<'a>()
        -> [ash::vk::VertexInputBindingDescription2EXT<'a>; 1usize] {
            [ash::vk::VertexInputBindingDescription2EXT::default()
                .binding(0u32)
                .stride(4u32)
                .input_rate(ash::vk::VertexInputRate::VERTEX)
                .divisor(1)]
        }
        pub fn vertex_attribute_descriptions_2_ext<'a>()
        -> [ash::vk::VertexInputAttributeDescription2EXT<'a>; 1usize] {
            [ash::vk::VertexInputAttributeDescription2EXT::default()
                .location(0u32)
                .binding(0u32)
                .format(ash::vk::Format::R32_UINT)
                .offset(0u32)]
        }
    }
    pub mod fragment_main {
        pub const ENTRY_POINT: &core::ffi::CStr = c"fragmentMain";
        pub const STAGE: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::FRAGMENT;
    }
    #[repr(C)]
    #[derive(Clone, Copy, Debug, Default, bytemuck :: Zeroable, bytemuck :: Pod)]
    pub struct Line {
        pub start: [f32; 2usize],
        pub end: [f32; 2usize],
        pub colour: [f32; 4usize],
    }
    impl Line {
        pub const STAGES: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::VERTEX;
        pub fn push_constant_range() -> ash::vk::PushConstantRange {
            ash::vk::PushConstantRange::default()
                .offset(0)
                .size(32u32)
                .stage_flags(ash::vk::ShaderStageFlags::VERTEX)
        }
    }
    pub const BYTES: &[u8] = {
        #[repr(C, align(4))]
        struct Aligned<T: ?Sized>(T);
        const ALIGNED_DATA: &Aligned<[u8]> = &Aligned(*include_bytes!("spv/render_line.spv"));
        &ALIGNED_DATA.0
    };
}
pub mod render_selection {
    pub mod vertex_main {
        pub const ENTRY_POINT: &core::ffi::CStr = c"vertexMain";
        pub const STAGE: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::VERTEX;
        #[repr(C)]
        #[derive(Clone, Copy, Debug, Default, bytemuck :: Zeroable, bytemuck :: Pod)]
        pub struct Vertex {
            pub position: [f32; 2usize],
            pub colour: [f32; 4usize],
            pub placement: u32,
            pub movable: u32,
        }
        pub fn vertex_binding_descriptions() -> [ash::vk::VertexInputBindingDescription; 1usize] {
            [ash::vk::VertexInputBindingDescription::default()
                .binding(0u32)
                .stride(32u32)
                .input_rate(ash::vk::VertexInputRate::VERTEX)]
        }
        pub fn vertex_attribute_descriptions() -> [ash::vk::VertexInputAttributeDescription; 4usize]
        {
            [
                ash::vk::VertexInputAttributeDescription::default()
                    .location(0u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32G32_SFLOAT)
                    .offset(0u32),
                ash::vk::VertexInputAttributeDescription::default()
                    .location(1u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32G32B32A32_SFLOAT)
                    .offset(8u32),
                ash::vk::VertexInputAttributeDescription::default()
                    .location(2u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32_UINT)
                    .offset(24u32),
                ash::vk::VertexInputAttributeDescription::default()
                    .location(3u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32_UINT)
                    .offset(28u32),
            ]
        }
        pub fn vertex_binding_descriptions_2_ext<'a>()
        -> [ash::vk::VertexInputBindingDescription2EXT<'a>; 1usize] {
            [ash::vk::VertexInputBindingDescription2EXT::default()
                .binding(0u32)
                .stride(32u32)
                .input_rate(ash::vk::VertexInputRate::VERTEX)
                .divisor(1)]
        }
        pub fn vertex_attribute_descriptions_2_ext<'a>()
        -> [ash::vk::VertexInputAttributeDescription2EXT<'a>; 4usize] {
            [
                ash::vk::VertexInputAttributeDescription2EXT::default()
                    .location(0u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32G32_SFLOAT)
                    .offset(0u32),
                ash::vk::VertexInputAttributeDescription2EXT::default()
                    .location(1u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32G32B32A32_SFLOAT)
                    .offset(8u32),
                ash::vk::VertexInputAttributeDescription2EXT::default()
                    .location(2u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32_UINT)
                    .offset(24u32),
                ash::vk::VertexInputAttributeDescription2EXT::default()
                    .location(3u32)
                    .binding(0u32)
                    .format(ash::vk::Format::R32_UINT)
                    .offset(28u32),
            ]
        }
    }
    pub mod fragment_main {
        pub const ENTRY_POINT: &core::ffi::CStr = c"fragmentMain";
        pub const STAGE: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::FRAGMENT;
    }
    #[repr(C)]
    #[derive(Clone, Copy, Debug, Default, bytemuck :: Zeroable, bytemuck :: Pod)]
    pub struct Selection {
        pub start: [f32; 2usize],
        pub end: [f32; 2usize],
    }
    impl Selection {
        pub const STAGES: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::VERTEX;
        pub fn push_constant_range() -> ash::vk::PushConstantRange {
            ash::vk::PushConstantRange::default()
                .offset(0)
                .size(16u32)
                .stage_flags(ash::vk::ShaderStageFlags::VERTEX)
        }
    }
    pub const BYTES: &[u8] = {
        #[repr(C, align(4))]
        struct Aligned<T: ?Sized>(T);
        const ALIGNED_DATA: &Aligned<[u8]> = &Aligned(*include_bytes!("spv/render_selection.spv"));
        &ALIGNED_DATA.0
    };
}
pub mod tonemap_hdr_to_sdr {
    use ash_helper::VK_GLOBAL_ALLOCATOR;

    pub mod compute_main {
        pub const ENTRY_POINT: &core::ffi::CStr = c"main";
        pub const STAGE: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::COMPUTE;
        pub const DISPATCH_SIZE: [u32; 3] = [64u32, 4u32, 1u32];
    }
    #[repr(C)]
    #[derive(Clone, Copy, Debug, Default, bytemuck :: Zeroable, bytemuck :: Pod)]
    pub struct PushConstants {
        pub whitepoint: f32,
    }
    impl PushConstants {
        pub const STAGES: ash::vk::ShaderStageFlags = ash::vk::ShaderStageFlags::COMPUTE;
        pub fn push_constant_range() -> ash::vk::PushConstantRange {
            ash::vk::PushConstantRange::default()
                .offset(0)
                .size(4u32)
                .stage_flags(ash::vk::ShaderStageFlags::COMPUTE)
        }
    }
    pub unsafe fn set_layouts(
        device: &ash::Device,
        flags: ash::vk::DescriptorSetLayoutCreateFlags,
    ) -> Result<Vec<ash::vk::DescriptorSetLayout>, ash::vk::Result> {
        let set_0 = {
            let bindings = [
                ash::vk::DescriptorSetLayoutBinding::default()
                    .binding(0u32)
                    .descriptor_type(ash::vk::DescriptorType::STORAGE_IMAGE)
                    .descriptor_count(1)
                    .stage_flags(ash::vk::ShaderStageFlags::COMPUTE),
                ash::vk::DescriptorSetLayoutBinding::default()
                    .binding(1u32)
                    .descriptor_type(ash::vk::DescriptorType::STORAGE_IMAGE)
                    .descriptor_count(1)
                    .stage_flags(ash::vk::ShaderStageFlags::COMPUTE),
            ];
            let layout_info = ash::vk::DescriptorSetLayoutCreateInfo::default()
                .bindings(&bindings)
                .flags(flags);
            match unsafe {
                device.create_descriptor_set_layout(&layout_info, VK_GLOBAL_ALLOCATOR.as_deref())
            } {
                Ok(set) => set,
                Err(error) => {
                    return Err(error);
                }
            }
        };
        Ok(vec![set_0])
    }
    pub const BYTES: &[u8] = {
        #[repr(C, align(4))]
        struct Aligned<T: ?Sized>(T);
        const ALIGNED_DATA: &Aligned<[u8]> =
            &Aligned(*include_bytes!("spv/tonemap_hdr_to_sdr.spv"));
        &ALIGNED_DATA.0
    };
}
