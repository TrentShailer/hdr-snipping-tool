#version 450
// glslc --target-spv=spv1.3 maximum_source_pass.comp -o maximum_source_pass.spv

// Get subgroup f16 capabilities
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_subgroup_extended_types_float16 : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

// Size of a workgroup
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16f) uniform readonly image2D source_image;
layout(set = 0, binding = 1) buffer WriteLayout
{
    float16_t write_buffer[];
};

shared float16_t shared_data[1024];


void main() {
	// gl_LocalInvocationID is where this call is in the workgroup
	// gl_WorkGroupID is the workgroup currently being executed

	uint local_invocation_index = gl_LocalInvocationIndex; // The index of this call in the current dispatch
	uint dispatch_index = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x; // Index of this dispatch

	// This call of this dispatches pixel index.
	uint dispatch_px_x = gl_WorkGroupID.x * gl_WorkGroupSize.x; // each dispatch is gl_WorkGroupSize.x wide
	uint x_index = dispatch_px_x + gl_LocalInvocationID.x;

	uint dispatch_px_y = gl_WorkGroupID.y * gl_WorkGroupSize.y * gl_SubgroupSize; // each dispatch is gl_WorkGroupSize.x * gl_SubgroupSize tall
	uint y_index = dispatch_px_y + gl_LocalInvocationID.y * gl_SubgroupSize;

	for (uint i = 0; i < gl_SubgroupSize; i++) {
		uint fetch_y_index = y_index + i;

		vec4 color = imageLoad(source_image, ivec2(x_index, fetch_y_index));
		// Note: Loading and using right after causes Long Scoreboard Stall while waiting for the load to complete.
		float value = max(color.r, max(color.g, color.b));

		float iteration_maximum = subgroupMax(value);

		if (gl_SubgroupInvocationID == i) {
			shared_data[local_invocation_index] = float16_t(iteration_maximum);
		}
	}
	// synchronise threads to ensure shared_data is full before proceding with the reduction
	barrier();

	// Recusively reduce the numbers in shared memory
	for (uint s = 1024 / 2; s > 0; s>>=1) {
		if (local_invocation_index < s) {
			shared_data[local_invocation_index] = max(shared_data[local_invocation_index], shared_data[local_invocation_index + s]);
		}
		barrier();
	}

	// After reduction is complete the first thread can store the value this invocation has computed
	if (local_invocation_index == 0) {
		write_buffer[dispatch_index] = shared_data[0];
	}
}
